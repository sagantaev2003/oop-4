## Сагантай Адиль CS-204(s) 
# Бинарное дерево

**Бинарное дерево** — это дерево, которое либо пусто, либо состоит из узла (корня) с двумя двоичными поддеревьями: левым и правым.

**Структура данных:**

    struct Node {
        int info;      // значение узла
        Node *left;    // указатель на левое поддерево
        Node *right;   // указатель на правое поддерево
    };

**Процедура создания узла:**

    Node* New(int data) {
        Node* V = (Node*)malloc(sizeof(Node));
        V->info = data;
        V->left = V->right = NULL;
        return V;
    }

**Особенности:**

- Каждый узел имеет не более двух потомков;
- Высота дерева — длина максимального пути от корня до листа;
- **Полное бинарное дерево:** все листья на одном уровне, каждая внутренняя вершина имеет оба поддерева;
- **Сбалансированное дерево:** разница высот поддеревьев каждой вершины ≤ 1;
- **Сортирующее бинарное дерево:** левое поддерево содержит значения < узла, правое > узла.

**Сильные стороны:**

- Быстрый поиск, вставка и удаление элементов в среднем за O(log n);
- Простая рекурсивная реализация операций;
- Можно преобразовать лес в бинарное дерево для упрощения структуры.

**Слабые стороны:**

- Может вырождаться в линейный список при последовательной вставке упорядоченных элементов, теряя эффективность;
- Для поддержания эффективности требуется балансировка (например, АВЛ-деревья, красно-чёрные деревья).

## Операции с бинарным деревом

**Добавление вершины:**

**Алгоритм добавления вершины**
- Шаг 0. Первый элемент становится коневым.
- Шаг 1. Сравнить значение очередного элемента со значением в корне.
- Шаг 2. Если значение меньше, то в качестве корня принять левого потомка корня, иначе правого потомка. Перейти на Шаг 1.
- Шаг 3. Если потомка нет, то создать вершину и включить ее в дерево.

Пусть есть множество элементов {3,7,2,9,11,4,33,88,34,6}. Рассмотрим, как они добавляются сортирующее дерево.

<img width="690" height="509" alt="image" src="https://github.com/user-attachments/assets/888a1ff5-1f3f-4f06-97ab-ab0201334798" />  . <img width="426" height="663" alt="image" src="https://github.com/user-attachments/assets/ec64e03d-b544-4ec5-93f7-973ae0f7529a" />


**Удаление вершины:**

1. Лист.
2. Внутренняя вершина, имеющая одного поддерево.
3. Внутренняя вершина, имеющая оба поддерева. Сюда же входит случай удаления корня.

<img width="672" height="690" alt="image" src="https://github.com/user-attachments/assets/7d4dd47d-0082-441a-a32e-368a6f98eedb" />



**Подсчет узлов:**
Рекурсивная функция обхода всех узлов дерева.

    int Count(Node* v)
    {static int n=0;
    
    if ( !v ) return 0; // лист – окончание рекурсии
    Count(v->left); // обход левого поддерева
    n++;
    Count(v->right); // обход правого поддерева
    return n;
    };

**Обходы бинарного дерева:**

**Обход дерева** – это способ последовательного посещения узлов дерева, при котором каждый узел посещается только один раз.
Таблица 5

<img width="513" height="183" alt="image" src="https://github.com/user-attachments/assets/1db29441-2085-4e83-8b7f-86d42433d910" />

**Обходы в глубину**
**Существует три способа обхода дерева в глубину:**
1. прямой (корень-лево-право), Pre_order
2. поперечный (лево-корень-право), In_order
3. обратный (лево-право-корень), Post_order

- **В ширину (BFS):**
    - Посещение узлов по уровням слева направо, с использованием очереди

**Удаление бинарного дерева:**

    void DelTree(Node **v)
    {if(*v)
     { DelTree(&((*v)->left));
     DelTree(&((*v)->right));
     free(*v);
     }
    }

# Лабораторная работа № 4. Сортирующее бинарное дерево
Входные данные хранятся в текстовом файле и представляют собой наборы букв, слов, чисел.
**Задание 1. Написать функцию для построения сортирующего бинарного дерева по файлу данных.**
**Задание 2. Применить к полученному дереву процедуры обходов, результаты сохранить в файле.**
**Задание 3. Написать функцию, подсчитывающую высоту бинарного дерева.**
