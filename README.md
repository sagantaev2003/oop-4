## Сагантай Адиль CS-204(s) 
# Бинарное дерево

**Бинарное дерево** — это дерево, которое либо пусто, либо состоит из узла (корня) с двумя двоичными поддеревьями: левым и правым.

**Структура данных:**

    struct Node {
        int info;      // значение узла
        Node *left;    // указатель на левое поддерево
        Node *right;   // указатель на правое поддерево
    };

**Процедура создания узла:**

    Node* New(int data) {
        Node* V = (Node*)malloc(sizeof(Node));
        V->info = data;
        V->left = V->right = NULL;
        return V;
    }

**Особенности:**

- Каждый узел имеет не более двух потомков;
- Высота дерева — длина максимального пути от корня до листа;
- **Полное бинарное дерево:** все листья на одном уровне, каждая внутренняя вершина имеет оба поддерева;
- **Сбалансированное дерево:** разница высот поддеревьев каждой вершины ≤ 1;
- **Сортирующее бинарное дерево:** левое поддерево содержит значения < узла, правое > узла.

**Сильные стороны:**

- Быстрый поиск, вставка и удаление элементов в среднем за O(log n);
- Простая рекурсивная реализация операций;
- Можно преобразовать лес в бинарное дерево для упрощения структуры.

**Слабые стороны:**

- Может вырождаться в линейный список при последовательной вставке упорядоченных элементов, теряя эффективность;
- Для поддержания эффективности требуется балансировка (например, АВЛ-деревья, красно-чёрные деревья).

## Операции с бинарным деревом

**Добавление вершины:**

**Алгоритм добавления вершины**
Алгоритм добавления вершины в сортирующее дерево.
- Шаг 0. Первый элемент становится коневым.
- Шаг 1. Сравнить значение очередного элемента со значением в корне.
- Шаг 2. Если значение меньше, то в качестве корня принять левого потомка корня, иначе правого потомка. Перейти на Шаг 1.
- Шаг 3. Если потомка нет, то создать вершину и включить ее в дерево.




**Удаление вершины:**

- **Лист:** просто удаляем.
- **Внутренняя вершина с одним поддеревом:** заменяем её на поддерево.
- **Внутренняя вершина с двумя поддеревьями:** копируем минимальное значение из правого поддерева (или максимальное из левого).

**Подсчет узлов:**
Рекурсивная функция обхода всех узлов дерева.

**Обходы бинарного дерева:**

- **В глубину (DFS):**
    - Прямой (Pre-order): корень → левое → правое
    - Поперечный (In-order): левое → корень → правое
    - Обратный (Post-order): левое → правое → корень

- **В ширину (BFS):**
    - Посещение узлов по уровням слева направо, с использованием очереди

**Удаление дерева:**
- Используется обратный обход (Post-order) — сначала листья, затем родительские узлы.
