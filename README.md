## Сагантай Адиль CS-204(s) 
# Бинарное дерево

**Бинарное дерево** — это дерево, которое либо пусто, либо состоит из узла (корня) с двумя двоичными поддеревьями: левым и правым.

**Структура данных:**

    struct Node {
        int info;      // значение узла
        Node *left;    // указатель на левое поддерево
        Node *right;   // указатель на правое поддерево
    };

**Процедура создания узла:**

    Node* New(int data) {
        Node* V = (Node*)malloc(sizeof(Node));
        V->info = data;
        V->left = V->right = NULL;
        return V;
    }

**Особенности:**

- Каждый узел имеет не более двух потомков;
- Высота дерева — длина максимального пути от корня до листа;
- **Полное бинарное дерево:** все листья на одном уровне, каждая внутренняя вершина имеет оба поддерева;
- **Сбалансированное дерево:** разница высот поддеревьев каждой вершины ≤ 1;
- **Сортирующее бинарное дерево:** левое поддерево содержит значения < узла, правое > узла.

**Сильные стороны:**

- Быстрый поиск, вставка и удаление элементов в среднем за O(log n);
- Простая рекурсивная реализация операций;
- Можно преобразовать лес в бинарное дерево для упрощения структуры.

**Слабые стороны:**

- Может вырождаться в линейный список при последовательной вставке упорядоченных элементов, теряя эффективность;
- Для поддержания эффективности требуется балансировка (например, АВЛ-деревья, красно-чёрные деревья).

## Операции с бинарным деревом

**Добавление вершины:**

**Алгоритм добавления вершины**
- Шаг 0. Первый элемент становится коневым.
- Шаг 1. Сравнить значение очередного элемента со значением в корне.
- Шаг 2. Если значение меньше, то в качестве корня принять левого потомка корня, иначе правого потомка. Перейти на Шаг 1.
- Шаг 3. Если потомка нет, то создать вершину и включить ее в дерево.

Пусть есть множество элементов {3,7,2,9,11,4,33,88,34,6}. Рассмотрим, как они добавляются сортирующее дерево.

<img width="690" height="509" alt="image" src="https://github.com/user-attachments/assets/888a1ff5-1f3f-4f06-97ab-ab0201334798" />  . <img width="426" height="663" alt="image" src="https://github.com/user-attachments/assets/ec64e03d-b544-4ec5-93f7-973ae0f7529a" />


**Удаление вершины:**

1. Лист.
2. Внутренняя вершина, имеющая одного поддерево.
3. Внутренняя вершина, имеющая оба поддерева. Сюда же входит случай удаления корня.

<img width="672" height="690" alt="image" src="https://github.com/user-attachments/assets/7d4dd47d-0082-441a-a32e-368a6f98eedb" />



**Подсчет узлов:**
Рекурсивная функция обхода всех узлов дерева.

    int Count(Node* v)
    {static int n=0;
    
    if ( !v ) return 0; // лист – окончание рекурсии
    Count(v->left); // обход левого поддерева
    n++;
    Count(v->right); // обход правого поддерева
    return n;
    };

**Обходы бинарного дерева:**

- **В глубину (DFS):**
    - Прямой (Pre-order): корень → левое → правое
    - Поперечный (In-order): левое → корень → правое
    - Обратный (Post-order): левое → правое → корень

- **В ширину (BFS):**
    - Посещение узлов по уровням слева направо, с использованием очереди

**Удаление дерева:**
- Используется обратный обход (Post-order) — сначала листья, затем родительские узлы.
